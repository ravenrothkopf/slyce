\section{\texttt{slyce} example programs}
To give a taste for \texttt{slyce}, we first walk through a set of example programs that can be found in the \texttt{/examples} subdirectory of the \texttt{slyce} source code.
These examples provide a concrete reference for \texttt{slyce}'s key features discussed throughout the rest of this report.
While we do not explicitly cover the syntax of \texttt{slyce}, we hope that a pass over these examples, as well as the rest in the \texttt{/examples} subdirectory, serve as an extensive set of use cases.
The full syntax understood when referencing the \texttt{slyce} parser in \texttt{Parser.hs}.
 
\subsection{\texttt{vec.sly}: The \texttt{slyce} Hello World program}
\begin{figure}[h!]
\begin{lstlisting}
    data Nat where
        Zero,
        Succ of (Nat).

    zero = Zero.
    one = Succ zero.
    two = Succ one.
    three = Succ two.

    data Vec (a:U) (n:Nat) where
        Nil of (n = Zero),
        Cons of (m:Nat) (a) (Vec a m) (n = Succ m).

    head : (a:U) -> (n:Nat) -> Vec a (Succ n) -> a.
    head = \a. \n. \v.
        match v with
            | Cons m x xs -> x.

    v : Vec Nat three.
    v = Cons two one (Cons one two (Cons zero three Nil)).
\end{lstlisting}
\end{figure}

The classic use case for dependent types is a list that is indexed over a particular length.
In this program, we showcase the use of data constructors, $\Pi$ types, function declaration, and pattern matching.

The type-safe list data type, \texttt{Vec} is indexed over a specific length using the dependent type system. 
The implementation defines two new data types: \texttt{Nat} and \texttt{Vec}. 
\texttt{Nat} represents natural numbers and is defined recursively as either Zero or the successor of another Nat. 
\texttt{Vec} represents a list of values of type \texttt{a}, which has type \texttt{U} -- \texttt{slyce}'s type of types -- that has a length of \texttt{n} elements.

The \texttt{Vec} data type has two constructors: \texttt{Nil} and \texttt{Cons}. 
\texttt{Nil} creates an empty list with a length of zero, and \texttt{Cons} adds an element of type \texttt{a} to the beginning of an existing list of length \texttt{m}, resulting in a new list of the length of the tail incremented by one. 
The type of the \texttt{Cons} constructor includes a proof that the length of the resulting list is one more than the length of the input list.

The \texttt{head} function takes a \texttt{Vec} of length \texttt{Succ n} and returns its first element of type \texttt{a}. 
The function pattern matches on the input list, using the \texttt{Cons} constructor to extract the head element.
Notably, this function is type safe. 
This means that if we pass it an empty list, \texttt{slyce} will produce a type error, not an index out of bounds error.

The implementation also defines four values of type \texttt{Nat} representing the numbers zero, one, two, and three. 
Finally, it creates a \texttt{Vec} of type \texttt{Vec Nat three} with three elements, using the nested \texttt{Cons} constructor to construct the list.

\subsection{\texttt{largeelim.sly}: Dependent pattern matching/propositional equality}
\begin{figure}[h!]
\begin{lstlisting}
    not : Bool -> Bool .
    not = \x. if x then False else True.
    
    t : Bool -> U.
    t = \b. if b then Unit else Bool.
    
    bar : (y : Bool) -> t y.
    bar = \b. if b then () else True.    
\end{lstlisting}
\end{figure}

\subsection{\texttt{sym.sly}: Definitional equality}
\begin{figure}[h!]
\begin{lstlisting}
    sym : (a:U) -> (x:a) -> (y:a) -> (x = y) -> y = x.
    sym = \a. \x. \y. \pf. subst Refl by pf.

    not : Bool -> Bool.
    not = \x. if x then False else True.

    false_is_not_true : False = (not True).
    false_is_not_true = Refl.

    not_true_is_false = sym Bool False (not True) false_is_not_true.
\end{lstlisting}
\end{figure}
